static void ne2000_ioport_write(void *opaque, uint32_t addr, uint32_t val)
{
    NE2000State *s = (NE2000State*)opaque;
    int offset, page, index;

    addr &= 0xf;
	page = s->cmd >> 6;
	offset = addr | (page << 4);
	if (addr == E8390_CMD)
		page = offset = 0;
#ifdef DEBUG_NE2000
    write_log("NE2000: write reg=0x%x val=0x%02x\n", addr, val);
#endif
    if (addr == E8390_CMD) {
        /* control register */
        s->cmd = val;
		if ((val & E8390_STOP) && s->dp8390) {
			s->isr |= ENISR_RESET;
		}
        if (!(val & E8390_STOP)) { /* START bit makes no sense on RTL8029... */
            s->isr &= ~ENISR_RESET;
            /* test specific case: zero length transfer */
            if ((val & (E8390_RREAD | E8390_RWRITE)) && s->tcnt == 0) {
				s->isr |= ENISR_RDC;
                ne2000_update_irq(s);
            }
            if (val & E8390_TRANS) {
                index = (s->tpsr << 8);
                /* XXX: next 2 lines are a hack to make netware 3.11 work */
                if (index >= NE2000_PMEM_END)
                    index -= NE2000_PMEM_SIZE;
				// must be before ethernet_trigger
				s->tsr = ENTSR_PTX;
				s->isr |= ENISR_TX;
				s->cmd &= ~E8390_TRANS;
				/* fail safe: check range on the transmitted length  */
                if (index + s->tcnt <= NE2000_PMEM_END) {
					transmitbuffer = s->mem + index;
					transmitlen = s->tcnt;
#ifdef DEBUG_NE2000
					write_log("NE2000: %d byte transmit\n", s->tcnt);
#endif
					// loop back special case
					if (!(s->dcfg & 8)) {
						uae_u8 *p;
						int loopbackmode = (s->txcr >> 1) & 3;
						bool crcmode = (s->txcr & 1) != 0;
						uint32_t crc1, crc2;
						// loopback mode uses 16-bit transfers but even bytes are ignored.
						int byteoffset = s->byteswapsupported && (s->dcfg & 2)  ? 0 : 1;
						int looplen = transmitlen / 2;
						uae_u8 *loop = xmalloc(uae_u8, looplen + 4);
						for (int i = 0; i < looplen; i++) {
							loop[i] = transmitbuffer[i * 2 + byteoffset];
						}
						bool macmatch = memcmp(loop + 0, loop + 6, 6) == 0;
						// transmit checksum handling
						if (!crcmode) {
							// append checksum
							crc1 = get_crc32(loop, looplen);
							loop[looplen + 3] = (crc1 >> 24) & 0xff;
							loop[looplen + 2] = (crc1 >> 16) & 0xff;
							loop[looplen + 1] = (crc1 >>  8) & 0xff;
							loop[looplen + 0] = (crc1 >>  0) & 0xff;
							looplen += 4;
						}
						p = loop;
#ifdef DEBUG_NE2000
						write_log(_T("SMAC %02x.%02x.%02x.%02x.%02x.%02x DMAC %02x.%02x.%02x.%02x.%02x.%02x\n"),
							p[0], p[1], p[2], p[3], p[4], p[5],
							p[6], p[7], p[8], p[9], p[10], p[11]);
#endif

						// receive checksum handling
						crc1 = get_crc32(loop, looplen - 4);
						p = loop + looplen - 4;
						crc2 = (p[3] << 24) | (p[2] << 16) | (p[1] << 8) | (p[0]);
						if (macmatch && (!crcmode || (crcmode && crc1 != crc2))) {
							s->rsr = ENRSR_CRC;
							s->isr |= ENISR_RX_ERR;
						} else {
							s->rsr = ENRSR_RXOK;
						}
						s->tsr = ENTSR_PTX | ENTSR_CDH;
						if (loopbackmode == 1) {
							s->tsr |= ENTSR_CRS;
						}
						s->fifo[3] = (crc1 >> 24) & 0xff;
						s->fifo[2] = (crc1 >> 16) & 0xff;
						s->fifo[1] = (crc1 >>  8) & 0xff;
						s->fifo[0] = (crc1 >>  0) & 0xff;
						s->fifo_offset = 0;
						xfree(loop);
					} else {

						if (log_a2065 > 1) {
							const uae_u8 *dstmac = transmitbuffer;
							const uae_u8 *srcmac = transmitbuffer + 6;
							write_log(_T("NE2000>!DST:%02X.%02X.%02X.%02X.%02X.%02X SRC:%02X.%02X.%02X.%02X.%02X.%02X E=%04X S=%d\n"),
								dstmac[0], dstmac[1], dstmac[2], dstmac[3], dstmac[4], dstmac[5],
								srcmac[6], srcmac[7], srcmac[8], srcmac[9], srcmac[10], srcmac[11],
								(transmitbuffer[12] << 8) | transmitbuffer[13], transmitlen);
						}


						ethernet_trigger(td, sysdata);
					}
#if 0
					qemu_send_packet(qemu_get_queue(s->nic), s->mem + index, s->tcnt);
#endif
				}
                /* signal end of transfer */
                ne2000_update_irq(s);
            }
        }
    } else {
        page = s->cmd >> 6;
        offset = addr | (page << 4);
        switch(offset) {
        case EN0_STARTPG:
            s->start = val << 8;
            break;
        case EN0_STOPPG:
            s->stop = val << 8;
            break;
        case EN0_BOUNDARY:
            s->boundary = val;
            break;
        case EN0_IMR:
            s->imr = val;
            ne2000_update_irq(s);
            break;
        case EN0_TPSR:
            s->tpsr = val;
            break;
        case EN0_TCNTLO:
            s->tcnt = (s->tcnt & 0xff00) | val;
            break;
        case EN0_TCNTHI:
            s->tcnt = (s->tcnt & 0x00ff) | (val << 8);
            break;
        case EN0_RSARLO:
            s->rsar = (s->rsar & 0xff00) | val;
            break;
        case EN0_RSARHI:
            s->rsar = (s->rsar & 0x00ff) | (val << 8);
            break;
        case EN0_RCNTLO:
            s->rcnt = (s->rcnt & 0xff00) | val;
            break;
        case EN0_RCNTHI:
            s->rcnt = (s->rcnt & 0x00ff) | (val << 8);
            break;
		case EN0_RXCR:
			s->rxcr = val;
			break;
		case EN0_TXCR:
			s->txcr = val;
			break;
		case EN0_DCFG:
            s->dcfg = val;
            break;
        case EN0_ISR:
            s->isr &= ~(val & 0x7f);
            ne2000_update_irq(s);
            break;
		case EN1_PHYS:
		case EN1_PHYS + 1:
		case EN1_PHYS + 2:
		case EN1_PHYS + 3:
		case EN1_PHYS + 4:
		case EN1_PHYS + 5:
            s->phys[offset - EN1_PHYS] = val;
            break;
        case EN1_CURPAG:
            s->curpag = val;
            break;
		case EN1_MULT:
		case EN1_MULT + 1:
		case EN1_MULT + 2:
		case EN1_MULT + 3:
		case EN1_MULT + 4:
		case EN1_MULT + 5:
		case EN1_MULT + 6:
		case EN1_MULT + 7:
			s->mult[offset - EN1_MULT] = val;
            break;
		case EN3_9346CR:
			s->e9346cr = val;
			if ((val >> 6) == 1) {
				// auto-load mode: end it immdiately.
				s->config[0] = eeprom93xx_read_byte(s->eeprom, 0);
				s->config[1] = eeprom93xx_read_byte(s->eeprom, 1);
				s->config[2] = eeprom93xx_read_byte(s->eeprom, 2);
				s->config[3] = eeprom93xx_read_byte(s->eeprom, 3);
				s->cmd = 0x21;
				write_log(_T("RTL8029 autoload: %02x %02x %02x %02x\n"),
					s->config[0], s->config[1], s->config[2], s->config[3]);
			} else if ((val >> 6) == 2) {
				// 9346 programming
				eeprom93xx_write(s->eeprom, (val >> 3) & 1, (val >> 2) & 1, (val >> 1) & 1);
			}
			break;
		case EN3_CONFIG0:
		case EN3_CONFIG1:
		case EN3_CONFIG2:
		case EN3_CONFIG3:
			write_log(_T("CONFIG%d=%02x 9346CR=%02x\n"), offset - EN3_CONFIG0, val, s->e9346cr);
			if ((s->e9346cr >> 6) == 3) {
				s->config[offset - EN3_CONFIG0] = val;
			}
			break;
		default:
			write_log(_T("WRITE %02x\n"), offset);
			break;
		}
    }
}