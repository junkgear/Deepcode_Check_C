static void vga_draw_graphic(VGACommonState *s, int full_update)
{
    DisplaySurface *surface = qemu_console_surface(s->con);
    int y1, y, update, linesize, y_start, double_scan, mask, depth;
    int width, height, shift_control, line_offset, bwidth, bits;
    ram_addr_t page0, page1, page_min, page_max;
    int disp_width, multi_scan, multi_run;
    uint8_t *d, *d2;
    uint32_t v, addr1, addr;
    vga_draw_line_func *vga_draw_line;
#if defined(HOST_WORDS_BIGENDIAN) == defined(TARGET_WORDS_BIGENDIAN)
    static const bool byteswap = false;
#else
    static const bool byteswap = true;
#endif

    full_update |= update_basic_params(s);

    if (!full_update)
        vga_sync_dirty_bitmap(s);

    s->get_resolution(s, &width, &height);
    disp_width = width;

    shift_control = (s->gr[VGA_GFX_MODE] >> 5) & 3;

	// Cirrus hack. If extended modes enabled, make sure we don't emulate
	// standard VGA modes. SR7[0] isn't set by all software I tested. TW
	if (s->sr[7] & 1)
		shift_control = 2;

    double_scan = (s->cr[VGA_CRTC_MAX_SCAN] >> 7);
    if (shift_control != 1) {
        multi_scan = (((s->cr[VGA_CRTC_MAX_SCAN] & 0x1f) + 1) << double_scan)
            - 1;
    } else {
        /* in CGA modes, multi_scan is ignored */
        /* XXX: is it correct ? */
        multi_scan = double_scan;
    }
    multi_run = multi_scan;
    if (shift_control != s->shift_control ||
        double_scan != s->double_scan) {
        full_update = 1;
        s->shift_control = shift_control;
        s->double_scan = double_scan;
    }

    if (shift_control == 0) {
        if (s->sr[VGA_SEQ_CLOCK_MODE] & 8) {
            disp_width <<= 1;
        }
    } else if (shift_control == 1) {
        if (s->sr[VGA_SEQ_CLOCK_MODE] & 8) {
            disp_width <<= 1;
        }
    }

    depth = s->get_bpp(s);
	if (full_update)
		qemu_console_resize(s->con, disp_width, height);
    if (s->line_offset != s->last_line_offset ||
        disp_width != s->last_width ||
        height != s->last_height ||
        s->last_depth != depth) {
        if (depth == 32 || (depth == 16 && !byteswap)) {
            surface = qemu_create_displaysurface_from(disp_width,
                    height, depth, s->line_offset,
                    s->vram_ptr + (s->start_addr * 4), byteswap);
            dpy_gfx_replace_surface(s->con, surface);
        } else {
            qemu_console_resize(s->con, disp_width, height);
            surface = qemu_console_surface(s->con);
        }
        s->last_scr_width = disp_width;
        s->last_scr_height = height;
        s->last_width = disp_width;
        s->last_height = height;
        s->last_line_offset = s->line_offset;
        s->last_depth = depth;
        full_update = 1;
    } else if (is_buffer_shared(surface) &&
               (full_update || surface_data(surface) != s->vram_ptr
                + (s->start_addr * 4))) {
        DisplaySurface *surface;
        surface = qemu_create_displaysurface_from(disp_width,
                height, depth, s->line_offset,
                s->vram_ptr + (s->start_addr * 4), byteswap);
        dpy_gfx_replace_surface(s->con, surface);
    }

    s->rgb_to_pixel =
        rgb_to_pixel_dup_table[get_depth_index(surface)];

    if (shift_control == 0) {
        full_update |= update_palette16(s);
        if (s->sr[VGA_SEQ_CLOCK_MODE] & 8) {
            v = VGA_DRAW_LINE4D2;
        } else {
            v = VGA_DRAW_LINE4;
        }
        bits = 4;
    } else if (shift_control == 1) {
        full_update |= update_palette16(s);
        if (s->sr[VGA_SEQ_CLOCK_MODE] & 8) {
            v = VGA_DRAW_LINE2D2;
        } else {
            v = VGA_DRAW_LINE2;
        }
        bits = 4;
    } else {
        switch(s->get_bpp(s)) {
        default:
        case 0:
            full_update |= update_palette256(s);
            v = VGA_DRAW_LINE8D2;
            bits = 4;
            break;
        case 8:
            full_update |= update_palette256(s);
            v = s->double_scan2 ? VGA_DRAW_LINE8D2 : VGA_DRAW_LINE8;
            bits = 8;
            break;
        case 15:
			v = s->double_scan2 ? VGA_DRAW_LINE15X2 : VGA_DRAW_LINE15;
			bits = 16;
            break;
        case 16:
			v = s->double_scan2 ? VGA_DRAW_LINE16X2 : VGA_DRAW_LINE16;
			bits = 16;
            break;
        case 24:
			v = s->double_scan2 ? VGA_DRAW_LINE24X2 : VGA_DRAW_LINE24;
			bits = 24;
            break;
        case 32:
			v = s->double_scan2 ? VGA_DRAW_LINE32X2 : VGA_DRAW_LINE32;
			bits = 32;
            break;
        }
    }
    vga_draw_line = vga_draw_line_table[v * NB_DEPTHS +
                                        get_depth_index(surface)];

    if (!is_buffer_shared(surface) && s->cursor_invalidate) {
        s->cursor_invalidate(s);
    }

    line_offset = s->line_offset;
#if 0
    write_log("w=%d h=%d v=%d line_offset=%d cr[0x09]=0x%02x cr[0x17]=0x%02x linecmp=%d sr[0x01]=0x%02x\n",
           width, height, v, line_offset, s->cr[9], s->cr[VGA_CRTC_MODE],
           s->line_compare, s->sr[VGA_SEQ_CLOCK_MODE]);
#endif

    addr1 = (s->start_addr * 4);
    bwidth = (width * bits + 7) / 8;
    y_start = -1;
    page_min = -1;
    page_max = 0;
    d = surface_data(surface);
	if (!d)
		return;
	d2 = d;
	linesize = surface_stride(surface);
    y1 = 0;
    for(y = 0; y < height; y++) {
        addr = addr1;
        if (!(s->cr[VGA_CRTC_MODE] & 1)) {
            int shift;
            /* CGA compatibility handling */
            shift = 14 + ((s->cr[VGA_CRTC_MODE] >> 6) & 1);
            addr = (addr & ~(1 << shift)) | ((y1 & 1) << shift);
        }
        if (!(s->cr[VGA_CRTC_MODE] & 2)) {
            addr = (addr & ~0x8000) | ((y1 & 2) << 14);
        }

        update = full_update;

		if (addr + bwidth < s->vram_size) {
			page0 = addr;
			page1 = addr + bwidth - 1;
			update |= memory_region_get_dirty(&s->vram, page0, page1 - page0,
											  DIRTY_MEMORY_VGA) != 0;
			/* explicit invalidation for the hardware cursor */
			update |= (s->invalidated_y_table[y >> 5] >> (y & 0x1f)) & 1;
			if (update) {
				if (y_start < 0)
					y_start = y;
				if (page0 < page_min)
					page_min = page0;
				if (page1 > page_max)
					page_max = page1;
				if (!(is_buffer_shared(surface))) {
					vga_draw_line(s, d, s->vram_ptr + addr, width);
					if (s->cursor_draw_line)
						s->cursor_draw_line(s, d, y);
				}
			} else {
				if (y_start >= 0) {
					/* flush to display */
					dpy_gfx_update(s->con, 0, y_start,
								   disp_width, y - y_start);
					y_start = -1;
				}
			}
		}

		if (!multi_run) {
            mask = (s->cr[VGA_CRTC_MODE] & 3) ^ 3;
            if ((y1 & mask) == mask)
                addr1 += line_offset;
            y1++;
            multi_run = multi_scan;
        } else {
            multi_run--;
        }
        /* line compare acts on the displayed lines */
        if (y == s->line_compare)
            addr1 = 0;
        d += linesize;
    }

	// video window (overlay)
	if ((s->cr[0x3e] & 1) && bits >= 8) {

		void copyrow_scale(int monid, uint8_t *src, uint8_t *src_screen, uint8_t *dst,
			int sx, int sy, int sxadd, int width, int srcbytesperrow, int srcpixbytes,
			int screenbytesperrow, int screenpixbytes,
			int dx, int dy, int dstwidth, int dstheight, int dstbytesperrow, int dstpixbytes,
			bool ck, uint32_t colorkey,
			int convert_mode, uint32_t *p96_rgbx16p, uint32_t *clut, bool yuv_swap);
		void alloc_colors_picasso(int rw, int gw, int bw, int rs, int gs, int bs, int rgbfmt, uint32_t *rgbx16);
		int getconvert(int rgbformat, int pixbytes);

		int outbpp = surface_bits_per_pixel(surface) / 8;
		uint32_t format = (s->cr[0x3e] >> 1) & 7;
		bool clutmode = false;

		if (!s->cirrus_rgbx16) {
			s->cirrus_rgbx16 = (uint32_t*)malloc(65536 * 4);
		}
		int convert = 0;
		switch (format)
		{
			case 0: // YUV422
				convert = 14;
			break;
			case 1: // YUV411
				convert = 15;
			break;
			case 2: // CLUT
				clutmode = 1;
				convert = 1;
			break;
			default: // RGB
				convert = 5;
			break;
		}
		convert = getconvert(convert, outbpp);

		int ovl_format = 5;
		if (s->old_ovl_format != ovl_format) {
			alloc_colors_picasso(8, 8, 8, 16, 8, 0, ovl_format, s->cirrus_rgbx16);
			s->old_ovl_format = ovl_format;
		}

		uint32_t gfxbpp = bits;
		uint32_t vptr = ((s->cr[0x3c] & 15) << 18) | (s->cr[0x3b] << 10) | (s->cr[0x3a] << 2) | ((s->cr[0x5d] >> 2) & 3);
		uint32_t bytesperrow = (((s->cr[0x3c] >> 5) & 1) << 11) | (s->cr[0x3d] << 3);
		uint32_t r1sz = s->cr[0x33] | (((s->cr[0x36] >> 0) & 3) << 8);
		uint32_t r1adjust = s->cr[0x5d] & 3;
		uint32_t r2sz = s->cr[0x34] | (((s->cr[0x36] >> 2) & 3) << 8);
		uint32_t r2adjust = (s->cr[0x5d] >> 4) & 3;
		uint32_t r2dsz = s->cr[0x35] | (((s->cr[0x36] >> 4) & 3) << 8);
		uint32_t wvs = s->cr[0x37] | (((s->cr[0x39] >> 0) & 3) << 8);
		uint32_t wve = s->cr[0x38] | (((s->cr[0x39] >> 2) & 3) << 8);
		bool occlusion = ((s->cr[0x3e] >> 7) & 1) != 0 && bits < 24;
		uint32_t region1size = 32 * r1sz / gfxbpp + (r1adjust * 8 / gfxbpp);
		uint32_t region2size = 32 * r2sz / gfxbpp + (r2adjust * 8 / gfxbpp);
		uint32_t hzoom = s->cr[0x31];
		uint32_t vzoom = s->cr[0x32];
		uint32_t colorkey = 0;

		int keymode = (s->cr[0x1d] >> 3) & 7;
		// mask and chroma key ignored.
		if (keymode == 0) {
			colorkey = s->gr[0x0c];
		} else if (keymode == 1) {
			colorkey = s->gr[0x0c] | (s->gr[0x0d] << 8);
		} else {
			occlusion = false;
		}

		int overlaybpp = clutmode ? 1 : 2;
		int overlay_width = overlaybpp * r2dsz;
		int vertical_height = wve - wvs + 1;

		if (clutmode) {
			update_palette256(s);
			overlay_width *= 4;
		}

		if (!hzoom)
			hzoom = 256;
		if (!vzoom)
			vzoom = 256;

		int y = 0;
		for (int oy = 0; oy < vertical_height; oy++) {
			if (vptr + (y >> 8) * bytesperrow > s->vram_size)
				break;
			if (s->start_addr * 4 + wvs * line_offset > s->vram_size)
				break;
			if (d2 + wvs * linesize > s->vram_ptr + s->vram_size)
				break;
			copyrow_scale(s->monid, s->vram_ptr + vptr, s->vram_ptr + s->start_addr * 4, d2,
				0, y >> 8, hzoom, overlay_width, bytesperrow, overlaybpp,
				line_offset, bits / 8,
				region1size, wvs, width, height, linesize, outbpp,
				occlusion, colorkey,
				convert, s->cirrus_rgbx16, s->last_palette, false);
			wvs++;
			y += vzoom;
		}

		s->ovl_changed = 1;
		s->old_overlay = 1;

		if (y_start < 0 || y_start > wvs)
			y_start = wvs;
		if (y < wve)
			y = wve + 1;

	} else if (s->old_overlay) {

		s->old_overlay = 0;
		s->ovl_changed = 1;

	}

    if (y_start >= 0) {
        /* flush to display */
        dpy_gfx_update(s->con, 0, y_start,
                       disp_width, y - y_start);
    }
    /* reset modified pages */
    if (page_max >= page_min) {
        memory_region_reset_dirty(&s->vram,
                                  page_min,
                                  page_max - page_min,
                                  DIRTY_MEMORY_VGA);
    }
    memset(s->invalidated_y_table, 0, ((height + 31) >> 5) * 4);
}